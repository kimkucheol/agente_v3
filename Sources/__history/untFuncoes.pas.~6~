unit untFuncoes;
{
############################################################################
#  Autor   : Rogério Teixeira
#  Data    : 24.03.2015
#  Motivo  : Library dos Metodos Publicos (Globais)
############################################################################
}
interface
Uses
  Registry, IniFiles, SysUtils, Messages, Dialogs;

// Declarações
  // Le o arquivo ini
  function FncLeINI(Path:String;ChavePrincipal:String;ChaveSecundaria:String):String;
  // Grava o no arquivo ini
  procedure PrcGravaIni(Path:String;ChavePrincipal:String;ChaveSecundaria:String;Valor:String);
  // Executa e Retorna as mensagens do Prompt de comando do MSDOS
  function FncComandoMSDOS(Comando, DiretorioTrabalho: string): string;

implementation

function FncLeINI(Path:String;ChavePrincipal:String;ChaveSecundaria:String):String;
var
   IniFile : TIniFile;
begin
  IniFile := TIniFile.Create(Path);
  Result :=  IniFile.ReadString(ChavePrincipal,ChaveSecundaria,'');
end;


procedure PrcGravaIni(Path:String;ChavePrincipal:String;ChaveSecundaria:String;Valor:String);
var
  Arq_Ini : TiniFile;
begin
  try
    if FileExists(Path) then
    Begin
      Arq_Ini := TIniFile.Create(Path);
      Arq_Ini.WriteString(ChavePrincipal,ChaveSecundaria,Valor);
      Arq_Ini.Free;
    End;
  Except On E: Exception Do
    Begin
      Try Arq_Ini.Free; Except End;
      MessageDlg('03 ERRO: '+QuotedStr(E.Message),mtError,[mbOk],0);
    End;
  End;
end;

function FncComandoMSDOS(Comando, DiretorioTrabalho: string): string;
var
  saSegunranca: TSecurityAttributes;
  siInformacoesInicializacao: TStartupInfo;
  piInformacaoDoProcesso: TProcessInformation;
  hLeitura, hEscrita: THandle;
  bOk, bHandle: Boolean;
  Buffer: array[0..255] of AnsiChar;
  BytesLidos: Cardinal;
  Diretorio: string;
begin
  Result := '';
  with saSegunranca do
  begin
    nLength := SizeOf(saSegunranca);
    bInheritHandle := True;
    lpSecurityDescriptor := nil;
  end;
  CreatePipe(hLeitura, hEscrita, @saSegunranca, 0);
  try
    with siInformacoesInicializacao do
    begin
      FillChar(siInformacoesInicializacao, SizeOf(siInformacoesInicializacao), 0);
      cb := SizeOf(siInformacoesInicializacao);
      dwFlags := STARTF_USESHOWWINDOW or STARTF_USESTDHANDLES;
      wShowWindow := SW_Hide;
      hStdInput := GetStdHandle(STD_INPUT_HANDLE);
      hStdOutput := hEscrita;
      hStdError := hEscrita;
    end;
    Diretorio := DiretorioTrabalho;
    bHandle := CreateProcess(nil, PChar('cmd.exe /c ' + Comando), nil, nil, True, 0, nil,
    PChar(Diretorio), siInformacoesInicializacao, piInformacaoDoProcesso);
    CloseHandle(hEscrita);
    if bHandle then
    begin
      try
        repeat
          bOk := ReadFile(hLeitura, Buffer, 255, BytesLidos, nil);

          if BytesLidos > 0 then
          begin
            Buffer[BytesLidos] := #0;
            OemToAnsi(Buffer, Buffer);
            Result :=  Result + Buffer;
          end;
        until not bOk or (BytesLidos = 0);
        WaitForSingleObject(piInformacaoDoProcesso.hProcess, INFINITE);
      finally
        CloseHandle(piInformacaoDoProcesso.hThread);
        CloseHandle(piInformacaoDoProcesso.hProcess);
      end;
    end;
  finally
    CloseHandle(hLeitura);
  end;
end;


end.
